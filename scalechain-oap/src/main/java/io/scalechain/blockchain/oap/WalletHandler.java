package io.scalechain.blockchain.oap;

import io.scalechain.blockchain.oap.blockchain.IWalletInterface;
import io.scalechain.blockchain.oap.blockchain.OapWallet;
import io.scalechain.blockchain.oap.exception.OapException;
import io.scalechain.blockchain.oap.util.Pair;
import io.scalechain.blockchain.oap.wallet.OapTransactionDescriptor;
import io.scalechain.blockchain.transaction.CoinAddress;
import io.scalechain.wallet.WalletTransactionDescriptor;
import scala.Option;

import java.math.BigDecimal;
import java.util.*;

/**
 * Created by shannon on 17. 1. 5.
 */
public class WalletHandler {
  private static WalletHandler instance = new WalletHandler();

  public static WalletHandler get() {
    return instance;
  }

  //
  // API Methods
  //
  /**
   *
   * returns a list of every address assigned to a particular account.
   *
   * accountOption
   *   The name of an account. The default account ("") is shown by default.
   *
   * @param accountOption
   * @param includeWatchOnly
   * @return
   * @throws OapException
   */
  public List<CoinAddress> getAddressesByAccount(Option<String> accountOption, boolean includeWatchOnly) throws OapException {

    return OpenAssetsProtocol.get().wallet().getAddressesByAccount(accountOption, includeWatchOnly);
  }

  /**
   *  gets the asset balance in asset_id:quantity format across all accounts or for a particular account.
   *
   * accountOption
   *   The name of an account to get the balance for. An empty string (“”) is the default account (default). The string * will get the balance for all accounts.
   *
   *
   * minConf
   *   The minimum number of confirmations an externally-generated transaction must have before it is counted towards the balance.
   *   Transactions generated by this node are counted immediately.
   *   Typically, externally-generated transactions are payments to this wallet and transactions generated by this node are payments to other wallets.
   *   Use 0 to count unconfirmed transactions. Default is 1.
   *
   * includeWatchOnly
   *   If set to true, include watch-only addresses in details and calculations as if they were regular addresses belonging to the wallet.
   *   If set to false (the default), treat watch-only addresses as if they didn’t belong to this wallet.
   *
   * asstIds
   *   If set, the asset balance whith asset id is in assetIds
   *
   * @param accountOption
   * @param minConf
   * @param includeWatchOnly
   * @param assetIds
   * @return
   * @throws OapException
   */
  public List<AssetBalanceDesc> getAssetBalance(
    Option<String> accountOption, long minConf,
    boolean includeWatchOnly, List<String> assetIds
  ) throws OapException {
    List<AssetBalanceDesc> result = new ArrayList<AssetBalanceDesc>();
    HashMap<String, Long> map = new HashMap<String, Long>();
    HashSet<String> set = new HashSet<String>();
    set.addAll(assetIds);

    long totalCount = 0;
    long readCount;
    int count = Integer.MAX_VALUE;
    long skip = 0;
    do {
      readCount = getAssetBalance(map, accountOption, count, skip, minConf, includeWatchOnly, set);
      totalCount += readCount;
      skip += readCount;
    } while (readCount == count);

    for(Map.Entry<String, Long> entry : map.entrySet()) {
      result.add(AssetBalanceDesc.apply(entry.getKey(),entry.getValue().longValue()));
    }
    return result;
  }

  /**
   *  gets the balance in decimal bitcoins across all accounts or for a particular account.
   *
   * Account
   *   The name of an account to get the balance for. An empty string (“”) is the default account (default). The string * will get the balance for all accounts.
   *
   *
   * Min confirmations
   *   The minimum number of confirmations an externally-generated transaction must have before it is counted towards the balance.
   *   Transactions generated by this node are counted immediately.
   *   Typically, externally-generated transactions are payments to this wallet and transactions generated by this node are payments to other wallets.
   *   Use 0 to count unconfirmed transactions. Default is 1.
   *
   * IncludeWatchOnly
   *   If set to true, include watch-only addresses in details and calculations as if they were regular addresses belonging to the wallet.
   *   If set to false (the default), treat watch-only addresses as if they didn’t belong to this wallet.
   *
   * @param accountOption
   * @param minConf
   * @param includeWatchOnly
   * @return
   * @throws OapException
   *
   */
  public BigDecimal getBalance(Option<String> accountOption, long minConf, boolean includeWatchOnly) throws OapException {
    //
    // FROM API ListTransactions that uses Wallet.listTransactionsWithAsset().
    // // None means to list transactions from all accounts in the wallet.
    // val accountOption = if (account == "*") None else Some(account)
    //
    if (accountOption.isDefined()) {
      if (accountOption.get().equals("*")) {
        accountOption = Option.empty();
      }
    }

    BigDecimal balance = new BigDecimal(0);
    int skip = 0;
    int count = Integer.MAX_VALUE;
    int readCount;
    do {
      Pair<Integer, BigDecimal> pair  = getBalance(balance, accountOption, count, skip, minConf, includeWatchOnly);
      readCount = pair.getFirst(); balance = pair.getSecond();
      skip += readCount;
    } while (readCount == count);

    return balance;
  }

  //
  // Internal Methods
  //
  public Pair<Integer, BigDecimal> getBalance(
    BigDecimal balance,
    Option<String> accountOption, int count, long skip, long minConf, boolean includeWatchOnly
  ) throws OapException {
    IWalletInterface walletInterface = OpenAssetsProtocol.get().wallet().walletInterface();

    List<WalletTransactionDescriptor> descriptors = walletInterface.listTransactions(accountOption, count, skip, includeWatchOnly);
    for(WalletTransactionDescriptor desc : descriptors) {
      if (!desc.confirmations().isEmpty() && (long) desc.confirmations().get() < minConf) continue;
      BigDecimal amount = desc.amount().bigDecimal();
      balance = desc.category().equalsIgnoreCase("send") ? balance.subtract(amount) : balance.add(amount);
    }
    return new Pair<Integer, BigDecimal>(descriptors.size(), balance);
  }

  /**
   * Get Asset Balance
   * @param balances
   * @param accountOption
   * @param count
   * @param skip
   * @param minConf
   * @param includeWatchOnly
   * @param assetIds
   * @return
   * @throws OapException
   */

  public int getAssetBalance(
    HashMap<String, Long> balances,
    Option<String> accountOption, int count, long skip, long minConf, boolean includeWatchOnly,
    HashSet<String> assetIds
  ) throws OapException {
    OapWallet wallet = OpenAssetsProtocol.get().wallet();
    List<OapTransactionDescriptor> descriptors = wallet.listTransactionsWithAsset(accountOption, count, skip, includeWatchOnly);

    for (OapTransactionDescriptor desc : descriptors) {
      if (!desc.confirmations().isEmpty() && (long) desc.confirmations().get() < minConf) continue;
      BigDecimal amount = desc.amount().bigDecimal();
      if (!(amount.equals(IOapConstants.DUST_IN_BITCOIN))) continue;

      if (desc.asset_id().isEmpty()) {
        throw new OapException(OapException.INTERNAL_ERROR, "Asset Id is undefined.");
      }
      if (desc.quantity().isEmpty()) {
        throw new OapException(OapException.INTERNAL_ERROR, "Asset quantity is undefined.");
      }
      String assetId = desc.asset_id().get();

      if (assetIds.size() > 0 && !assetIds.contains(assetId)) {
        continue;
      }
      int quantity = ((Integer)(desc.quantity().get())).intValue();
      Long assetBalance = balances.get(assetId);
      if (assetBalance == null) assetBalance = 0L;
      assetBalance = desc.category().equalsIgnoreCase("send") ? assetBalance - quantity : assetBalance + quantity;
      balances.put(assetId, assetBalance);
    }

    return descriptors.size();
  }

  public List<OapTransactionDescriptor> listTransactionsWithAsset(Option<String> accountOption, int count, long skip, boolean includWatchOnly) throws OapException {
    return OpenAssetsProtocol.get().wallet().listTransactionsWithAsset(accountOption, count, skip, includWatchOnly);
  }
}
